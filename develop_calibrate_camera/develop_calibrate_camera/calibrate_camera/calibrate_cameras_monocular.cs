//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 12.0
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
  public HDevelopExport()
  {
    // Default settings used in HDevelop 
    HOperatorSet.SetSystem("width", 512);
    HOperatorSet.SetSystem("height", 512);
    if (HalconAPI.isWindows)
      HOperatorSet.SetSystem("use_window_thread","true");
    action();
  }
#endif

  // Procedures 
  // External procedures 
  // Chapter: Develop
  // Short Description: Open a new graphics window that preserves the aspect ratio of the given image size. 
  public void dev_open_window_fit_size (HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
      HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
    HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
    HTuple hv_ResizeFactor = null, hv_TempWidth = null, hv_TempHeight = null;
    HTuple hv_WindowWidth = null, hv_WindowHeight = null;
    // Initialize local and output iconic variables 
    //This procedure open a new graphic window
    //such that it fits into the limits specified by WidthLimit
    //and HeightLimit, but also maintains the correct aspect ratio
    //given by Width and Height.
    //
    //If it is impossible to match the minimum and maximum extent requirements
    //at the same time (f.e. if the image is very long but narrow),
    //the maximum value gets a higher priority.
    //
    //Parse input tuple WidthLimit
    if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
    {
      hv_MinWidth = 500;
      hv_MaxWidth = 800;
    }
    else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinWidth = 0;
      hv_MaxWidth = hv_WidthLimit.Clone();
    }
    else
    {
      hv_MinWidth = hv_WidthLimit[0];
      hv_MaxWidth = hv_WidthLimit[1];
    }
    //Parse input tuple HeightLimit
    if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
    {
      hv_MinHeight = 400;
      hv_MaxHeight = 600;
    }
    else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinHeight = 0;
      hv_MaxHeight = hv_HeightLimit.Clone();
    }
    else
    {
      hv_MinHeight = hv_HeightLimit[0];
      hv_MaxHeight = hv_HeightLimit[1];
    }
    //
    //Test, if window size has to be changed.
    hv_ResizeFactor = 1;
    //First, expand window to the minimum extents (if necessary).
    if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_Width))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
        hv_Height)))) != 0)
    {
      hv_ResizeFactor = (((((hv_MinWidth.TupleReal())/hv_Width)).TupleConcat((hv_MinHeight.TupleReal()
          )/hv_Height))).TupleMax();
    }
    hv_TempWidth = hv_Width*hv_ResizeFactor;
    hv_TempHeight = hv_Height*hv_ResizeFactor;
    //Then, shrink window to maximum extents (if necessary).
    if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
        hv_TempHeight)))) != 0)
    {
      hv_ResizeFactor = hv_ResizeFactor*((((((hv_MaxWidth.TupleReal())/hv_TempWidth)).TupleConcat(
          (hv_MaxHeight.TupleReal())/hv_TempHeight))).TupleMin());
    }
    hv_WindowWidth = hv_Width*hv_ResizeFactor;
    hv_WindowHeight = hv_Height*hv_ResizeFactor;
    //Resize window
    HOperatorSet.SetWindowAttr("background_color","black");
    HOperatorSet.OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"","",out hv_WindowHandle);
    HDevWindowStack.Push(hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height-1, hv_Width-1);
    }

    return;
  }

  // Chapter: Develop
  // Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
  public void dev_update_off ()
  {

    // Initialize local and output iconic variables 
    //This procedure sets different update settings to 'off'.
    //This is useful to get the best performance and reduce overhead.
    //
    // dev_update_pc(...); only in hdevelop
    // dev_update_var(...); only in hdevelop
    // dev_update_window(...); only in hdevelop

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: Set font independent of OS 
  public void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
      HTuple hv_Bold, HTuple hv_Slant)
  {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_OS = null, hv_BufferWindowHandle = new HTuple();
        HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
        HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
        HTuple hv_Scale = new HTuple(), hv_Exception = new HTuple();
        HTuple hv_SubFamily = new HTuple(), hv_Fonts = new HTuple();
        HTuple hv_SystemFonts = new HTuple(), hv_Guess = new HTuple();
        HTuple hv_I = new HTuple(), hv_Index = new HTuple(), hv_AllowedFontSizes = new HTuple();
        HTuple hv_Distances = new HTuple(), hv_Indices = new HTuple();
        HTuple hv_FontSelRegexp = new HTuple(), hv_FontsCourier = new HTuple();
        HTuple   hv_Bold_COPY_INP_TMP = hv_Bold.Clone();
        HTuple   hv_Font_COPY_INP_TMP = hv_Font.Clone();
        HTuple   hv_Size_COPY_INP_TMP = hv_Size.Clone();
        HTuple   hv_Slant_COPY_INP_TMP = hv_Slant.Clone();

        // Initialize local and output iconic variables 
    //This procedure sets the text font of the current window with
    //the specified attributes.
    //It is assumed that following fonts are installed on the system:
    //Windows: Courier New, Arial Times New Roman
    //Mac OS X: CourierNewPS, Arial, TimesNewRomanPS
    //Linux: courier, helvetica, times
    //Because fonts are displayed smaller on Linux than on Windows,
    //a scaling factor of 1.25 is used the get comparable results.
    //For Linux, only a limited number of font sizes is supported,
    //to get comparable results, it is recommended to use one of the
    //following sizes: 9, 11, 14, 16, 20, 27
    //(which will be mapped internally on Linux systems to 11, 14, 17, 20, 25, 34)
    //
    //Input parameters:
    //WindowHandle: The graphics window for which the font will be set
    //Size: The font size. If Size=-1, the default of 16 is used.
    //Bold: If set to 'true', a bold font is used
    //Slant: If set to 'true', a slanted font is used
    //
    HOperatorSet.GetSystem("operating_system", out hv_OS);
    // dev_get_preferences(...); only in hdevelop
    // dev_set_preferences(...); only in hdevelop
    if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
        new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
    {
      hv_Size_COPY_INP_TMP = 16;
    }
    if ((int)(new HTuple(((hv_OS.TupleSubstr(0,2))).TupleEqual("Win"))) != 0)
    {
      //Set font on Windows systems
      try
      {
        //Check, if font scaling is switched on
        HOperatorSet.OpenWindow(0, 0, 256, 256, 0, "buffer", "", out hv_BufferWindowHandle);
        HOperatorSet.SetFont(hv_BufferWindowHandle, "-Consolas-16-*-0-*-*-1-");
        HOperatorSet.GetStringExtents(hv_BufferWindowHandle, "test_string", out hv_Ascent, 
            out hv_Descent, out hv_Width, out hv_Height);
        //Expected width is 110
        hv_Scale = 110.0/hv_Width;
        hv_Size_COPY_INP_TMP = ((hv_Size_COPY_INP_TMP*hv_Scale)).TupleInt();
        HOperatorSet.CloseWindow(hv_BufferWindowHandle);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //throw (Exception)
      }
      if ((int)((new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))).TupleOr(
          new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("courier")))) != 0)
      {
        hv_Font_COPY_INP_TMP = "Courier New";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
      {
        hv_Font_COPY_INP_TMP = "Consolas";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
      {
        hv_Font_COPY_INP_TMP = "Arial";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
      {
        hv_Font_COPY_INP_TMP = "Times New Roman";
      }
      if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        hv_Bold_COPY_INP_TMP = 1;
      }
      else if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("false"))) != 0)
      {
        hv_Bold_COPY_INP_TMP = 0;
      }
      else
      {
        hv_Exception = "Wrong value of control parameter Bold";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        hv_Slant_COPY_INP_TMP = 1;
      }
      else if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("false"))) != 0)
      {
        hv_Slant_COPY_INP_TMP = 0;
      }
      else
      {
        hv_Exception = "Wrong value of control parameter Slant";
        throw new HalconException(hv_Exception);
      }
      try
      {
        HOperatorSet.SetFont(hv_WindowHandle, ((((((("-"+hv_Font_COPY_INP_TMP)+"-")+hv_Size_COPY_INP_TMP)+"-*-")+hv_Slant_COPY_INP_TMP)+"-*-*-")+hv_Bold_COPY_INP_TMP)+"-");
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //throw (Exception)
      }
    }
    else if ((int)(new HTuple(((hv_OS.TupleSubstr(0,2))).TupleEqual("Dar"))) != 0)
    {
      //Set font on Mac OS X systems. Since OS X does not have a strict naming
      //scheme for font attributes, we use tables to determine the correct font
      //name.
      hv_SubFamily = 0;
      if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        hv_SubFamily = hv_SubFamily.TupleBor(1);
      }
      else if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleNotEqual("false"))) != 0)
      {
        hv_Exception = "Wrong value of control parameter Slant";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        hv_SubFamily = hv_SubFamily.TupleBor(2);
      }
      else if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleNotEqual("false"))) != 0)
      {
        hv_Exception = "Wrong value of control parameter Bold";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
      {
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "Menlo-Regular";
        hv_Fonts[1] = "Menlo-Italic";
        hv_Fonts[2] = "Menlo-Bold";
        hv_Fonts[3] = "Menlo-BoldItalic";
      }
      else if ((int)((new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))).TupleOr(
          new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("courier")))) != 0)
      {
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "CourierNewPSMT";
        hv_Fonts[1] = "CourierNewPS-ItalicMT";
        hv_Fonts[2] = "CourierNewPS-BoldMT";
        hv_Fonts[3] = "CourierNewPS-BoldItalicMT";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
      {
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "ArialMT";
        hv_Fonts[1] = "Arial-ItalicMT";
        hv_Fonts[2] = "Arial-BoldMT";
        hv_Fonts[3] = "Arial-BoldItalicMT";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
      {
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "TimesNewRomanPSMT";
        hv_Fonts[1] = "TimesNewRomanPS-ItalicMT";
        hv_Fonts[2] = "TimesNewRomanPS-BoldMT";
        hv_Fonts[3] = "TimesNewRomanPS-BoldItalicMT";
      }
      else
      {
        //Attempt to figure out which of the fonts installed on the system
        //the user could have meant.
        HOperatorSet.QueryFont(hv_WindowHandle, out hv_SystemFonts);
        hv_Fonts = new HTuple();
        hv_Fonts = hv_Fonts.TupleConcat(hv_Font_COPY_INP_TMP);
        hv_Fonts = hv_Fonts.TupleConcat(hv_Font_COPY_INP_TMP);
        hv_Fonts = hv_Fonts.TupleConcat(hv_Font_COPY_INP_TMP);
        hv_Fonts = hv_Fonts.TupleConcat(hv_Font_COPY_INP_TMP);
        hv_Guess = new HTuple();
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP);
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-Regular");
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"MT");
        for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_Guess.TupleLength()))-1); hv_I = (int)hv_I + 1)
        {
          HOperatorSet.TupleFind(hv_SystemFonts, hv_Guess.TupleSelect(hv_I), out hv_Index);
          if ((int)(new HTuple(hv_Index.TupleNotEqual(-1))) != 0)
          {
            if (hv_Fonts == null)
              hv_Fonts = new HTuple();
            hv_Fonts[0] = hv_Guess.TupleSelect(hv_I);
            break;
          }
        }
        //Guess name of slanted font
        hv_Guess = new HTuple();
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-Italic");
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-ItalicMT");
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-Oblique");
        for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_Guess.TupleLength()))-1); hv_I = (int)hv_I + 1)
        {
          HOperatorSet.TupleFind(hv_SystemFonts, hv_Guess.TupleSelect(hv_I), out hv_Index);
          if ((int)(new HTuple(hv_Index.TupleNotEqual(-1))) != 0)
          {
            if (hv_Fonts == null)
              hv_Fonts = new HTuple();
            hv_Fonts[1] = hv_Guess.TupleSelect(hv_I);
            break;
          }
        }
        //Guess name of bold font
        hv_Guess = new HTuple();
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-Bold");
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-BoldMT");
        for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_Guess.TupleLength()))-1); hv_I = (int)hv_I + 1)
        {
          HOperatorSet.TupleFind(hv_SystemFonts, hv_Guess.TupleSelect(hv_I), out hv_Index);
          if ((int)(new HTuple(hv_Index.TupleNotEqual(-1))) != 0)
          {
            if (hv_Fonts == null)
              hv_Fonts = new HTuple();
            hv_Fonts[2] = hv_Guess.TupleSelect(hv_I);
            break;
          }
        }
        //Guess name of bold slanted font
        hv_Guess = new HTuple();
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-BoldItalic");
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-BoldItalicMT");
        hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP+"-BoldOblique");
        for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_Guess.TupleLength()))-1); hv_I = (int)hv_I + 1)
        {
          HOperatorSet.TupleFind(hv_SystemFonts, hv_Guess.TupleSelect(hv_I), out hv_Index);
          if ((int)(new HTuple(hv_Index.TupleNotEqual(-1))) != 0)
          {
            if (hv_Fonts == null)
              hv_Fonts = new HTuple();
            hv_Fonts[3] = hv_Guess.TupleSelect(hv_I);
            break;
          }
        }
      }
      hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(hv_SubFamily);
      try
      {
        HOperatorSet.SetFont(hv_WindowHandle, (hv_Font_COPY_INP_TMP+"-")+hv_Size_COPY_INP_TMP);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //throw (Exception)
      }
    }
    else
    {
      //Set font for UNIX systems
      hv_Size_COPY_INP_TMP = hv_Size_COPY_INP_TMP*1.25;
      hv_AllowedFontSizes = new HTuple();
      hv_AllowedFontSizes[0] = 11;
      hv_AllowedFontSizes[1] = 14;
      hv_AllowedFontSizes[2] = 17;
      hv_AllowedFontSizes[3] = 20;
      hv_AllowedFontSizes[4] = 25;
      hv_AllowedFontSizes[5] = 34;
      if ((int)(new HTuple(((hv_AllowedFontSizes.TupleFind(hv_Size_COPY_INP_TMP))).TupleEqual(
          -1))) != 0)
      {
        hv_Distances = ((hv_AllowedFontSizes-hv_Size_COPY_INP_TMP)).TupleAbs();
        HOperatorSet.TupleSortIndex(hv_Distances, out hv_Indices);
        hv_Size_COPY_INP_TMP = hv_AllowedFontSizes.TupleSelect(hv_Indices.TupleSelect(
            0));
      }
      if ((int)((new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))).TupleOr(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(
          "Courier")))) != 0)
      {
        hv_Font_COPY_INP_TMP = "courier";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
      {
        hv_Font_COPY_INP_TMP = "helvetica";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
      {
        hv_Font_COPY_INP_TMP = "times";
      }
      if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        hv_Bold_COPY_INP_TMP = "bold";
      }
      else if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("false"))) != 0)
      {
        hv_Bold_COPY_INP_TMP = "medium";
      }
      else
      {
        hv_Exception = "Wrong value of control parameter Bold";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("true"))) != 0)
      {
        if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("times"))) != 0)
        {
          hv_Slant_COPY_INP_TMP = "i";
        }
        else
        {
          hv_Slant_COPY_INP_TMP = "o";
        }
      }
      else if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("false"))) != 0)
      {
        hv_Slant_COPY_INP_TMP = "r";
      }
      else
      {
        hv_Exception = "Wrong value of control parameter Slant";
        throw new HalconException(hv_Exception);
      }
      try
      {
        HOperatorSet.SetFont(hv_WindowHandle, ((((((("-adobe-"+hv_Font_COPY_INP_TMP)+"-")+hv_Bold_COPY_INP_TMP)+"-")+hv_Slant_COPY_INP_TMP)+"-normal-*-")+hv_Size_COPY_INP_TMP)+"-*-*-*-*-*-*-*");
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        if ((int)((new HTuple(((hv_OS.TupleSubstr(0,4))).TupleEqual("Linux"))).TupleAnd(
            new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("courier")))) != 0)
        {
          HOperatorSet.QueryFont(hv_WindowHandle, out hv_Fonts);
          hv_FontSelRegexp = (("^-[^-]*-[^-]*[Cc]ourier[^-]*-"+hv_Bold_COPY_INP_TMP)+"-")+hv_Slant_COPY_INP_TMP;
          hv_FontsCourier = ((hv_Fonts.TupleRegexpSelect(hv_FontSelRegexp))).TupleRegexpMatch(
              hv_FontSelRegexp);
          if ((int)(new HTuple((new HTuple(hv_FontsCourier.TupleLength())).TupleEqual(
              0))) != 0)
          {
            hv_Exception = "Wrong font name";
            //throw (Exception)
          }
          else
          {
            try
            {
              HOperatorSet.SetFont(hv_WindowHandle, (((hv_FontsCourier.TupleSelect(
                  0))+"-normal-*-")+hv_Size_COPY_INP_TMP)+"-*-*-*-*-*-*-*");
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException2)
            {
              HDevExpDefaultException2.ToHTuple(out hv_Exception);
              //throw (Exception)
            }
          }
        }
        //throw (Exception)
      }
    }
    // dev_set_preferences(...); only in hdevelop

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen. 
  public void disp_continue_message (HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ContinueMessage = null, hv_Row = null;
    HTuple hv_Column = null, hv_Width = null, hv_Height = null;
    HTuple hv_Ascent = null, hv_Descent = null, hv_TextWidth = null;
    HTuple hv_TextHeight = null;
    // Initialize local and output iconic variables 
    //This procedure displays 'Press Run (F5) to continue' in the
    //lower right corner of the screen.
    //It uses the procedure disp_message.
    //
    //Input parameters:
    //WindowHandle: The window, where the text shall be displayed
    //Color: defines the text color.
    //   If set to '' or 'auto', the currently set color is used.
    //Box: If set to 'true', the text is displayed in a box.
    //
    hv_ContinueMessage = "Press Run (F5) to continue";
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Width, 
        out hv_Height);
    HOperatorSet.GetStringExtents(hv_WindowHandle, (" "+hv_ContinueMessage)+" ", 
        out hv_Ascent, out hv_Descent, out hv_TextWidth, out hv_TextHeight);
    disp_message(hv_WindowHandle, hv_ContinueMessage, "window", (hv_Height-hv_TextHeight)-12, 
        (hv_Width-hv_TextWidth)-12, hv_Color, hv_Box);

    return;
  }

  // Chapter: Graphics / Text
  // Short Description: This procedure writes a text message. 
  public void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
      HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
  {



      // Local iconic variables 

      // Local control variables 

      HTuple hv_Red = null, hv_Green = null, hv_Blue = null;
      HTuple hv_Row1Part = null, hv_Column1Part = null, hv_Row2Part = null;
      HTuple hv_Column2Part = null, hv_RowWin = null, hv_ColumnWin = null;
      HTuple hv_WidthWin = null, hv_HeightWin = null, hv_MaxAscent = null;
      HTuple hv_MaxDescent = null, hv_MaxWidth = null, hv_MaxHeight = null;
      HTuple hv_R1 = new HTuple(), hv_C1 = new HTuple(), hv_FactorRow = new HTuple();
      HTuple hv_FactorColumn = new HTuple(), hv_UseShadow = null;
      HTuple hv_ShadowColor = null, hv_Exception = new HTuple();
      HTuple hv_Width = new HTuple(), hv_Index = new HTuple();
      HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
      HTuple hv_W = new HTuple(), hv_H = new HTuple(), hv_FrameHeight = new HTuple();
      HTuple hv_FrameWidth = new HTuple(), hv_R2 = new HTuple();
      HTuple hv_C2 = new HTuple(), hv_DrawMode = new HTuple();
      HTuple hv_CurrentColor = new HTuple();
      HTuple   hv_Box_COPY_INP_TMP = hv_Box.Clone();
      HTuple   hv_Color_COPY_INP_TMP = hv_Color.Clone();
      HTuple   hv_Column_COPY_INP_TMP = hv_Column.Clone();
      HTuple   hv_Row_COPY_INP_TMP = hv_Row.Clone();
      HTuple   hv_String_COPY_INP_TMP = hv_String.Clone();

      // Initialize local and output iconic variables 
    //This procedure displays text in a graphics window.
    //
    //Input parameters:
    //WindowHandle: The WindowHandle of the graphics window, where
    //   the message should be displayed
    //String: A tuple of strings containing the text message to be displayed
    //CoordSystem: If set to 'window', the text position is given
    //   with respect to the window coordinate system.
    //   If set to 'image', image coordinates are used.
    //   (This may be useful in zoomed images.)
    //Row: The row coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //Column: The column coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //Color: defines the color of the text as string.
    //   If set to [], '' or 'auto' the currently set color is used.
    //   If a tuple of strings is passed, the colors are used cyclically
    //   for each new textline.
    //Box: If Box[0] is set to 'true', the text is written within an orange box.
    //     If set to' false', no box is displayed.
    //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
    //       the text is written in a box of that color.
    //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
    //       'true' -> display a shadow in a default color
    //       'false' -> display no shadow (same as if no second value is given)
    //       otherwise -> use given string as color string for the shadow color
    //
    //Prepare window
    HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
    HOperatorSet.GetPart(hv_WindowHandle, out hv_Row1Part, out hv_Column1Part, out hv_Row2Part, 
        out hv_Column2Part);
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowWin, out hv_ColumnWin, 
        out hv_WidthWin, out hv_HeightWin);
    HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
    //
    //default settings
    if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
    {
      hv_Row_COPY_INP_TMP = 12;
    }
    if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
    {
      hv_Column_COPY_INP_TMP = 12;
    }
    if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
    {
      hv_Color_COPY_INP_TMP = "";
    }
    //
    hv_String_COPY_INP_TMP = (((""+hv_String_COPY_INP_TMP)+"")).TupleSplit("\n");
    //
    //Estimate extentions of text depending on font size.
    HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent, 
        out hv_MaxWidth, out hv_MaxHeight);
    if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
    {
      hv_R1 = hv_Row_COPY_INP_TMP.Clone();
      hv_C1 = hv_Column_COPY_INP_TMP.Clone();
    }
    else
    {
      //Transform image to window coordinates
      hv_FactorRow = (1.0*hv_HeightWin)/((hv_Row2Part-hv_Row1Part)+1);
      hv_FactorColumn = (1.0*hv_WidthWin)/((hv_Column2Part-hv_Column1Part)+1);
      hv_R1 = ((hv_Row_COPY_INP_TMP-hv_Row1Part)+0.5)*hv_FactorRow;
      hv_C1 = ((hv_Column_COPY_INP_TMP-hv_Column1Part)+0.5)*hv_FactorColumn;
    }
    //
    //Display text box depending on text size
    hv_UseShadow = 1;
    hv_ShadowColor = "gray";
    if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleEqual("true"))) != 0)
    {
      if (hv_Box_COPY_INP_TMP == null)
        hv_Box_COPY_INP_TMP = new HTuple();
      hv_Box_COPY_INP_TMP[0] = "#fce9d4";
      hv_ShadowColor = "#f28d26";
    }
    if ((int)(new HTuple((new HTuple(hv_Box_COPY_INP_TMP.TupleLength())).TupleGreater(
        1))) != 0)
    {
      if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual("true"))) != 0)
      {
        //Use default ShadowColor set above
      }
      else if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual(
          "false"))) != 0)
      {
        hv_UseShadow = 0;
      }
      else
      {
        hv_ShadowColor = hv_Box_COPY_INP_TMP[1];
        //Valid color?
        try
        {
          HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(
              1));
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          hv_Exception = "Wrong value of control parameter Box[1] (must be a 'true', 'false', or a valid color string)";
          throw new HalconException(hv_Exception);
        }
      }
    }
    if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleNotEqual("false"))) != 0)
    {
      //Valid color?
      try
      {
        HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(0));
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_Exception = "Wrong value of control parameter Box[0] (must be a 'true', 'false', or a valid color string)";
        throw new HalconException(hv_Exception);
      }
      //Calculate box extents
      hv_String_COPY_INP_TMP = (" "+hv_String_COPY_INP_TMP)+" ";
      hv_Width = new HTuple();
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
            hv_Index), out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
        hv_Width = hv_Width.TupleConcat(hv_W);
      }
      hv_FrameHeight = hv_MaxHeight*(new HTuple(hv_String_COPY_INP_TMP.TupleLength()
          ));
      hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
      hv_R2 = hv_R1+hv_FrameHeight;
      hv_C2 = hv_C1+hv_FrameWidth;
      //Display rectangles
      HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
      HOperatorSet.SetDraw(hv_WindowHandle, "fill");
      //Set shadow color
      HOperatorSet.SetColor(hv_WindowHandle, hv_ShadowColor);
      if ((int)(hv_UseShadow) != 0)
      {
        HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1+1, hv_C1+1, hv_R2+1, hv_C2+1);
      }
      //Set box color
      HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(0));
      HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
      HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
    }
    //Write text.
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index%(new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
          )));
      if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
          "auto")))) != 0)
      {
        HOperatorSet.SetColor(hv_WindowHandle, hv_CurrentColor);
      }
      else
      {
        HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
      }
      hv_Row_COPY_INP_TMP = hv_R1+(hv_MaxHeight*hv_Index);
      HOperatorSet.SetTposition(hv_WindowHandle, hv_Row_COPY_INP_TMP, hv_C1);
      HOperatorSet.WriteString(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
          hv_Index));
    }
    //Reset changed window settings
    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    HOperatorSet.SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, 
        hv_Column2Part);

    return;
  }

  // Chapter: File
  // Short Description: Get all image files under the given path 
  public void list_image_files (HTuple hv_ImageDirectory, HTuple hv_Extensions, HTuple hv_Options, 
      out HTuple hv_ImageFiles)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_HalconImages = null, hv_OS = null;
    HTuple hv_Directories = null, hv_Index = null, hv_Length = null;
    HTuple hv_network_drive = null, hv_Substring = new HTuple();
    HTuple hv_FileExists = new HTuple(), hv_AllFiles = new HTuple();
    HTuple hv_i = new HTuple(), hv_Selection = new HTuple();
    HTuple   hv_Extensions_COPY_INP_TMP = hv_Extensions.Clone();
    HTuple   hv_ImageDirectory_COPY_INP_TMP = hv_ImageDirectory.Clone();

    // Initialize local and output iconic variables 
    //This procedure returns all files in a given directory
    //with one of the suffixes specified in Extensions.
    //
    //input parameters:
    //ImageDirectory: as the name says
    //   If a tuple of directories is given, only the images in the first
    //   existing directory are returned.
    //   If a local directory is not found, the directory is searched
    //   under %HALCONIMAGES%/ImageDirectory. If %HALCONIMAGES% is not set,
    //   %HALCONROOT%/images is used instead.
    //Extensions: A string tuple containing the extensions to be found
    //   e.g. ['png','tif',jpg'] or others
    //If Extensions is set to 'default' or the empty string '',
    //   all image suffixes supported by HALCON are used.
    //Options: as in the operator list_files, except that the 'files'
    //   option is always used. Note that the 'directories' option
    //   has no effect but increases runtime, because only files are
    //   returned.
    //
    //output parameter:
    //ImageFiles: A tuple of all found image file names
    //
    if ((int)((new HTuple((new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
        new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(""))))).TupleOr(new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(
        "default")))) != 0)
    {
      hv_Extensions_COPY_INP_TMP = new HTuple();
      hv_Extensions_COPY_INP_TMP[0] = "ima";
      hv_Extensions_COPY_INP_TMP[1] = "tif";
      hv_Extensions_COPY_INP_TMP[2] = "tiff";
      hv_Extensions_COPY_INP_TMP[3] = "gif";
      hv_Extensions_COPY_INP_TMP[4] = "bmp";
      hv_Extensions_COPY_INP_TMP[5] = "jpg";
      hv_Extensions_COPY_INP_TMP[6] = "jpeg";
      hv_Extensions_COPY_INP_TMP[7] = "jp2";
      hv_Extensions_COPY_INP_TMP[8] = "jxr";
      hv_Extensions_COPY_INP_TMP[9] = "png";
      hv_Extensions_COPY_INP_TMP[10] = "pcx";
      hv_Extensions_COPY_INP_TMP[11] = "ras";
      hv_Extensions_COPY_INP_TMP[12] = "xwd";
      hv_Extensions_COPY_INP_TMP[13] = "pbm";
      hv_Extensions_COPY_INP_TMP[14] = "pnm";
      hv_Extensions_COPY_INP_TMP[15] = "pgm";
      hv_Extensions_COPY_INP_TMP[16] = "ppm";
      //
    }
    if ((int)(new HTuple(hv_ImageDirectory_COPY_INP_TMP.TupleEqual(""))) != 0)
    {
      hv_ImageDirectory_COPY_INP_TMP = ".";
    }
    HOperatorSet.GetSystem("image_dir", out hv_HalconImages);
    HOperatorSet.GetSystem("operating_system", out hv_OS);
    if ((int)(new HTuple(((hv_OS.TupleSubstr(0,2))).TupleEqual("Win"))) != 0)
    {
      hv_HalconImages = hv_HalconImages.TupleSplit(";");
    }
    else
    {
      hv_HalconImages = hv_HalconImages.TupleSplit(":");
    }
    hv_Directories = hv_ImageDirectory_COPY_INP_TMP.Clone();
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_HalconImages.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      hv_Directories = hv_Directories.TupleConcat(((hv_HalconImages.TupleSelect(hv_Index))+"/")+hv_ImageDirectory_COPY_INP_TMP);
    }
    HOperatorSet.TupleStrlen(hv_Directories, out hv_Length);
    HOperatorSet.TupleGenConst(new HTuple(hv_Length.TupleLength()), 0, out hv_network_drive);
    if ((int)(new HTuple(((hv_OS.TupleSubstr(0,2))).TupleEqual("Win"))) != 0)
    {
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Length.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
      {
        if ((int)(new HTuple(((((hv_Directories.TupleSelect(hv_Index))).TupleStrlen()
            )).TupleGreater(1))) != 0)
        {
          HOperatorSet.TupleStrFirstN(hv_Directories.TupleSelect(hv_Index), 1, out hv_Substring);
          if ((int)(new HTuple(hv_Substring.TupleEqual("//"))) != 0)
          {
            if (hv_network_drive == null)
              hv_network_drive = new HTuple();
            hv_network_drive[hv_Index] = 1;
          }
        }
      }
    }
    hv_ImageFiles = new HTuple();
    for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Directories.TupleLength()
        ))-1); hv_Index = (int)hv_Index + 1)
    {
      HOperatorSet.FileExists(hv_Directories.TupleSelect(hv_Index), out hv_FileExists);
      if ((int)(hv_FileExists) != 0)
      {
        HOperatorSet.ListFiles(hv_Directories.TupleSelect(hv_Index), (new HTuple("files")).TupleConcat(
            hv_Options), out hv_AllFiles);
        hv_ImageFiles = new HTuple();
        for (hv_i=0; (int)hv_i<=(int)((new HTuple(hv_Extensions_COPY_INP_TMP.TupleLength()
            ))-1); hv_i = (int)hv_i + 1)
        {
          HOperatorSet.TupleRegexpSelect(hv_AllFiles, (((".*"+(hv_Extensions_COPY_INP_TMP.TupleSelect(
              hv_i)))+"$")).TupleConcat("ignore_case"), out hv_Selection);
          hv_ImageFiles = hv_ImageFiles.TupleConcat(hv_Selection);
        }
        HOperatorSet.TupleRegexpReplace(hv_ImageFiles, (new HTuple("\\\\")).TupleConcat(
            "replace_all"), "/", out hv_ImageFiles);
        if ((int)(hv_network_drive.TupleSelect(hv_Index)) != 0)
        {
          HOperatorSet.TupleRegexpReplace(hv_ImageFiles, (new HTuple("//")).TupleConcat(
              "replace_all"), "/", out hv_ImageFiles);
          hv_ImageFiles = "/"+hv_ImageFiles;
        }
        else
        {
          HOperatorSet.TupleRegexpReplace(hv_ImageFiles, (new HTuple("//")).TupleConcat(
              "replace_all"), "/", out hv_ImageFiles);
        }

        return;
      }
    }

    return;
  }

  // Local procedures 
  public void add_circle_offset (HTuple hv_XOff, HTuple hv_YOff, HTuple hv_Radius, 
      HTuple hv_PointX, HTuple hv_PointY, HTuple hv_PointZ, HTuple hv_PolySequence, 
      out HTuple hv_PointXOut, out HTuple hv_PointYOut, out HTuple hv_PointZOut, out HTuple hv_PolySequenceOut)
  {



    // Local iconic variables 

    HObject ho_ContCircle;

    // Local control variables 

    HTuple hv_Row = null, hv_Col = null, hv_Sequence = null;
    HTuple hv_Zeros = null;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ContCircle);
    try
    {
      hv_PointXOut = hv_PointX.Clone();
      hv_PointYOut = hv_PointY.Clone();
      hv_PointZOut = hv_PointZ.Clone();
      hv_PolySequenceOut = hv_PolySequence.Clone();
      ho_ContCircle.Dispose();
      HOperatorSet.GenCircleContourXld(out ho_ContCircle, hv_XOff, hv_YOff, hv_Radius, 
          0, 6.28318, "positive", 0.05*hv_Radius);
      HOperatorSet.GetContourXld(ho_ContCircle, out hv_Row, out hv_Col);
      hv_Sequence = new HTuple();
      hv_Sequence = hv_Sequence.TupleConcat(new HTuple(hv_Row.TupleLength()
          ));
      hv_Sequence = hv_Sequence.TupleConcat((new HTuple(hv_PointX.TupleLength()
          ))+HTuple.TupleGenSequence(0,(new HTuple(hv_Row.TupleLength()))-1,1));
      hv_PointXOut = hv_PointXOut.TupleConcat(hv_Row);
      hv_PointYOut = hv_PointYOut.TupleConcat(hv_Col);
      HOperatorSet.TupleGenConst(new HTuple(hv_Row.TupleLength()), 0, out hv_Zeros);
      hv_PointZOut = hv_PointZOut.TupleConcat(hv_Zeros);
      //
      hv_PolySequenceOut = hv_PolySequenceOut.TupleConcat(hv_Sequence);
      //
      ho_ContCircle.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_ContCircle.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void create_caltab_object_model (HTuple hv_XNum, HTuple hv_YNum, HTuple hv_MarkDist, 
      HTuple hv_DiameterRatio, HTuple hv_FinderX, HTuple hv_FinderY, out HTuple hv_ObjectModel3D)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_PointX = null, hv_PointY = null;
    HTuple hv_PointZ = null, hv_PolySequence = null, hv_XOff = null;
    HTuple hv_YOff = null, hv_Radius = null, hv_Spacing = null;
    HTuple hv_NumX = null, hv_NumY = null, hv_SpacingY = null;
    HTuple hv_OffsetX = null, hv_OffsetY = null, hv_FX = null;
    HTuple hv_FY = null, hv_Linear = null, hv_XSeq = null;
    HTuple hv_YSeq = null, hv_AllX = null, hv_AllY = null;
    HTuple hv_R = null, hv_RX = null, hv_RY = null, hv_I = null;
    HTuple hv_X = new HTuple(), hv_Y = new HTuple(), hv_StartPhi = null;
    HTuple hv_EndPhi = null, hv_Fdx = null;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObjectModel3d(out hv_ObjectModel3D);
    hv_PointX = new HTuple();
    hv_PointY = new HTuple();
    hv_PointZ = new HTuple();
    hv_PolySequence = new HTuple();
    hv_XOff = 0.0;
    hv_YOff = 0.0;
    hv_Radius = (0.5*hv_DiameterRatio)*hv_MarkDist;
    hv_Spacing = hv_MarkDist.Clone();
    hv_NumX = hv_XNum.Clone();
    hv_NumY = hv_YNum.Clone();
    //
    hv_SpacingY = ((new HTuple(0.75)).TupleSqrt())*hv_Spacing;
    //
    hv_OffsetX = ((hv_NumX/2)*hv_Spacing)-(0.25*hv_Spacing);
    hv_OffsetY = (hv_NumY/2)*hv_SpacingY;
    //
    //coordinates of all finder pattern marks
    hv_FX = new HTuple();
    hv_FX = hv_FX.TupleConcat(hv_FinderX);
    hv_FX = hv_FX.TupleConcat(hv_FinderX+1);
    hv_FX = hv_FX.TupleConcat(hv_FinderX);
    hv_FX = hv_FX.TupleConcat(hv_FinderX);
    hv_FX = hv_FX.TupleConcat(hv_FinderX+1);
    hv_FX = hv_FX.TupleConcat(hv_FinderX+1);
    hv_FX = hv_FX.TupleConcat(hv_FinderX-1);
    hv_FY = new HTuple();
    hv_FY = hv_FY.TupleConcat(hv_FinderY);
    hv_FY = hv_FY.TupleConcat(hv_FinderY-1);
    hv_FY = hv_FY.TupleConcat(hv_FinderY-1);
    hv_FY = hv_FY.TupleConcat(hv_FinderY+1);
    hv_FY = hv_FY.TupleConcat(hv_FinderY);
    hv_FY = hv_FY.TupleConcat(hv_FinderY+1);
    hv_FY = hv_FY.TupleConcat(hv_FinderY);
    if (hv_FX == null)
      hv_FX = new HTuple();
    hv_FX[5] = (hv_FX.TupleSelect(5))-1;
    if (hv_FX == null)
      hv_FX = new HTuple();
    hv_FX[10] = (hv_FX.TupleSelect(10))-1;
    if (hv_FX == null)
      hv_FX = new HTuple();
    hv_FX[15] = (hv_FX.TupleSelect(15))-1;
    if (hv_FX == null)
      hv_FX = new HTuple();
    hv_FX[25] = (hv_FX.TupleSelect(25))-1;
    //
    hv_Linear = (hv_XNum*hv_FY)+hv_FX;
    hv_XSeq = HTuple.TupleGenSequence(0,hv_XNum-1,1);
    hv_YSeq = HTuple.TupleGenConst(hv_XNum,0);
    hv_AllX = new HTuple();
    hv_AllY = new HTuple();
    HTuple end_val30 = hv_YNum-1;
    HTuple step_val30 = 1;
    for (hv_R=0; hv_R.Continue(end_val30, step_val30); hv_R = hv_R.TupleAdd(step_val30))
    {
      hv_AllX = hv_AllX.TupleConcat(hv_XSeq);
      hv_AllY = hv_AllY.TupleConcat(hv_YSeq+hv_R);
    }
    hv_RX = hv_AllX.TupleRemove(hv_Linear);
    hv_RY = hv_AllY.TupleRemove(hv_Linear);
    //add all marks except the finder pattern marks
    for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_RX.TupleLength()))-1); hv_I = (int)hv_I + 1)
    {
      hv_X = hv_RX.TupleSelect(hv_I);
      hv_Y = hv_RY.TupleSelect(hv_I);
      if ((int)(new HTuple(((hv_Y%2)).TupleEqual(1))) != 0)
      {
        add_circle_offset((-hv_OffsetX)+((hv_X-0.25)*hv_Spacing), (-hv_OffsetY)+(hv_Y*hv_SpacingY), 
            hv_Radius, hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, 
            out hv_PointY, out hv_PointZ, out hv_PolySequence);
      }
      else
      {
        add_circle_offset((-hv_OffsetX)+((hv_X+0.25)*hv_Spacing), (-hv_OffsetY)+(hv_Y*hv_SpacingY), 
            hv_Radius, hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, 
            out hv_PointY, out hv_PointZ, out hv_PolySequence);
      }
    }
    //
    hv_StartPhi = ((((((((new HTuple((new HTuple(90)).TupleRad())).TupleConcat((new HTuple(180)).TupleRad()
        ))).TupleConcat((new HTuple(0)).TupleRad()))).TupleConcat((new HTuple(0)).TupleRad()
        ))).TupleConcat((new HTuple(270)).TupleRad()))-((new HTuple(45)).TupleRad()
        );
    hv_EndPhi = ((((((((new HTuple((new HTuple(180)).TupleRad())).TupleConcat((new HTuple(270)).TupleRad()
        ))).TupleConcat((new HTuple(0)).TupleRad()))).TupleConcat((new HTuple(90)).TupleRad()
        ))).TupleConcat((new HTuple(360)).TupleRad()))+((new HTuple(45)).TupleRad()
        );
    if (hv_StartPhi == null)
      hv_StartPhi = new HTuple();
    hv_StartPhi[2] = hv_EndPhi.TupleSelect(2);
    //
    //
    //add first finder
    add_circle_with_hole_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(0))-1)+0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(0))-1)*hv_SpacingY), hv_Radius, hv_PointX, 
        hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, out hv_PointZ, 
        out hv_PolySequence);
    add_circle_with_hole_offset((-hv_OffsetX)+(((hv_FinderX.TupleSelect(0))+0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(0))-1)*hv_SpacingY), hv_Radius, hv_PointX, 
        hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, out hv_PointZ, 
        out hv_PolySequence);
    //
    add_circle_with_hole_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(0))-1)-0.25)*hv_Spacing), 
        (-hv_OffsetY)+((hv_FinderY.TupleSelect(0))*hv_SpacingY), hv_Radius, hv_PointX, 
        hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, out hv_PointZ, 
        out hv_PolySequence);
    add_circle_with_hole_offset((-hv_OffsetX)+(((hv_FinderX.TupleSelect(0))-0.25)*hv_Spacing), 
        (-hv_OffsetY)+((hv_FinderY.TupleSelect(0))*hv_SpacingY), hv_Radius, hv_PointX, 
        hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, out hv_PointZ, 
        out hv_PolySequence);
    add_circle_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(0))+1)-0.25)*hv_Spacing), 
        (-hv_OffsetY)+((hv_FinderY.TupleSelect(0))*hv_SpacingY), hv_Radius, hv_PointX, 
        hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, out hv_PointZ, 
        out hv_PolySequence);
    //
    add_circle_with_hole_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(0))-1)+0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(0))+1)*hv_SpacingY), hv_Radius, hv_PointX, 
        hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, out hv_PointZ, 
        out hv_PolySequence);
    add_circle_with_hole_offset((-hv_OffsetX)+(((hv_FinderX.TupleSelect(0))+0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(0))+1)*hv_SpacingY), hv_Radius, hv_PointX, 
        hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, out hv_PointZ, 
        out hv_PolySequence);
    //
    //add scnd finder
    hv_Fdx = 1;
    add_circle_with_hole_offset((-hv_OffsetX)+(((hv_FinderX.TupleSelect(hv_Fdx))-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))-1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))+1)-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))-1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    //
    add_circle_with_hole_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))-1)+0.25)*hv_Spacing), 
        (-hv_OffsetY)+((hv_FinderY.TupleSelect(hv_Fdx))*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_offset((-hv_OffsetX)+(((hv_FinderX.TupleSelect(hv_Fdx))+0.25)*hv_Spacing), 
        (-hv_OffsetY)+((hv_FinderY.TupleSelect(hv_Fdx))*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_with_hole_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))+1)+0.25)*hv_Spacing), 
        (-hv_OffsetY)+((hv_FinderY.TupleSelect(hv_Fdx))*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    //
    add_circle_with_hole_offset((-hv_OffsetX)+(((hv_FinderX.TupleSelect(hv_Fdx))-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))+1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))+1)-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))+1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    //
    //
    //add third finder
    hv_Fdx = 2;
    add_circle_offset((-hv_OffsetX)+(((hv_FinderX.TupleSelect(hv_Fdx))-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))-1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))+1)-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))-1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    //
    add_circle_with_hole_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))-1)+0.25)*hv_Spacing), 
        (-hv_OffsetY)+((hv_FinderY.TupleSelect(hv_Fdx))*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_with_hole_offset((-hv_OffsetX)+(((hv_FinderX.TupleSelect(hv_Fdx))+0.25)*hv_Spacing), 
        (-hv_OffsetY)+((hv_FinderY.TupleSelect(hv_Fdx))*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_with_hole_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))+1)+0.25)*hv_Spacing), 
        (-hv_OffsetY)+((hv_FinderY.TupleSelect(hv_Fdx))*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    //
    add_circle_offset((-hv_OffsetX)+(((hv_FinderX.TupleSelect(hv_Fdx))-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))+1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_with_hole_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))+1)-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))+1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    //
    //
    //add fourth finder
    hv_Fdx = 3;
    add_circle_offset((-hv_OffsetX)+(((hv_FinderX.TupleSelect(hv_Fdx))-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))-1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))+1)-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))-1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    //
    add_circle_with_hole_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))-1)+0.25)*hv_Spacing), 
        (-hv_OffsetY)+((hv_FinderY.TupleSelect(hv_Fdx))*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_with_hole_offset((-hv_OffsetX)+(((hv_FinderX.TupleSelect(hv_Fdx))+0.25)*hv_Spacing), 
        (-hv_OffsetY)+((hv_FinderY.TupleSelect(hv_Fdx))*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_with_hole_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))+1)+0.25)*hv_Spacing), 
        (-hv_OffsetY)+((hv_FinderY.TupleSelect(hv_Fdx))*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    //
    add_circle_with_hole_offset((-hv_OffsetX)+(((hv_FinderX.TupleSelect(hv_Fdx))-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))+1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))+1)-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))+1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    //
    //
    //add fifth finder
    hv_Fdx = 4;
    add_circle_with_hole_offset((-hv_OffsetX)+(((hv_FinderX.TupleSelect(hv_Fdx))-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))-1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_with_hole_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))+1)-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))-1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    //
    add_circle_with_hole_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))-1)+0.25)*hv_Spacing), 
        (-hv_OffsetY)+((hv_FinderY.TupleSelect(hv_Fdx))*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_offset((-hv_OffsetX)+(((hv_FinderX.TupleSelect(hv_Fdx))+0.25)*hv_Spacing), 
        (-hv_OffsetY)+((hv_FinderY.TupleSelect(hv_Fdx))*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))+1)+0.25)*hv_Spacing), 
        (-hv_OffsetY)+((hv_FinderY.TupleSelect(hv_Fdx))*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    //
    add_circle_with_hole_offset((-hv_OffsetX)+(((hv_FinderX.TupleSelect(hv_Fdx))-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))+1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    add_circle_offset((-hv_OffsetX)+((((hv_FinderX.TupleSelect(hv_Fdx))+1)-0.25)*hv_Spacing), 
        (-hv_OffsetY)+(((hv_FinderY.TupleSelect(hv_Fdx))+1)*hv_SpacingY), hv_Radius, 
        hv_PointX, hv_PointY, hv_PointZ, hv_PolySequence, out hv_PointX, out hv_PointY, 
        out hv_PointZ, out hv_PolySequence);
    //
    HOperatorSet.SetObjectModel3dAttribMod(hv_ObjectModel3D, ((new HTuple("point_coord_x")).TupleConcat(
        "point_coord_y")).TupleConcat("point_coord_z"), new HTuple(), ((hv_PointX.TupleConcat(
        hv_PointY))).TupleConcat(hv_PointZ));
    HOperatorSet.SetObjectModel3dAttribMod(hv_ObjectModel3D, "polygons", new HTuple(), 
        hv_PolySequence);
    //

    return;
  }

  public void add_circle_with_hole_offset (HTuple hv_XOff, HTuple hv_YOff, HTuple hv_Radius, 
      HTuple hv_PointX, HTuple hv_PointY, HTuple hv_PointZ, HTuple hv_PolySequence, 
      out HTuple hv_PointXOut, out HTuple hv_PointYOut, out HTuple hv_PointZOut, out HTuple hv_PolySequenceOut)
  {



    // Local iconic variables 

    HObject ho_ContCircle;

    // Local control variables 

    HTuple hv_Row = null, hv_Col = null, hv_RowH = null;
    HTuple hv_ColH = null, hv_Sequence = null, hv_Num = null;
    HTuple hv_Off = null, hv_Idx = null, hv_Zeros = null;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ContCircle);
    try
    {
      hv_PointXOut = hv_PointX.Clone();
      hv_PointYOut = hv_PointY.Clone();
      hv_PointZOut = hv_PointZ.Clone();
      hv_PolySequenceOut = hv_PolySequence.Clone();
      //Radius := 1
      ho_ContCircle.Dispose();
      HOperatorSet.GenCircleContourXld(out ho_ContCircle, 0.0, 0.0, hv_Radius, 0, 
          6.28318, "positive", 0.05*hv_Radius);
      HOperatorSet.GetContourXld(ho_ContCircle, out hv_Row, out hv_Col);
      hv_RowH = (1.0/3.0)*hv_Row;
      hv_ColH = (1.0/3.0)*hv_Col;
      //disp_object_model_3d can only handle convex polygons, so we
      //have to triangulate this by hand
      hv_Sequence = new HTuple();
      hv_Num = new HTuple(hv_Row.TupleLength());
      hv_Off = new HTuple(hv_PointX.TupleLength());
      HTuple end_val14 = hv_Num-2;
      HTuple step_val14 = 1;
      for (hv_Idx=0; hv_Idx.Continue(end_val14, step_val14); hv_Idx = hv_Idx.TupleAdd(step_val14))
      {
        hv_Sequence = ((((((hv_Sequence.TupleConcat(3))).TupleConcat(hv_Off+hv_Idx))).TupleConcat(
            (hv_Off+hv_Idx)+hv_Num))).TupleConcat((hv_Off+hv_Idx)+1);
        hv_Sequence = ((((((hv_Sequence.TupleConcat(3))).TupleConcat((hv_Off+hv_Idx)+1))).TupleConcat(
            (hv_Off+hv_Idx)+hv_Num))).TupleConcat(((hv_Off+hv_Idx)+hv_Num)+1);
      }
      hv_Sequence = ((((((hv_Sequence.TupleConcat(3))).TupleConcat((hv_Off+hv_Num)-1))).TupleConcat(
          ((hv_Off+hv_Num)-1)+hv_Num))).TupleConcat(hv_Off+0);
      hv_Sequence = ((((((hv_Sequence.TupleConcat(3))).TupleConcat(hv_Off+0))).TupleConcat(
          hv_Off+hv_Num))).TupleConcat(((hv_Off+hv_Num)+hv_Num)-1);
      //
      hv_Row = (hv_Row.TupleConcat(hv_RowH))+hv_XOff;
      hv_Col = (hv_Col.TupleConcat(hv_ColH))+hv_YOff;
      //
      hv_PointXOut = hv_PointXOut.TupleConcat(hv_Row);
      hv_PointYOut = hv_PointYOut.TupleConcat(hv_Col);
      HOperatorSet.TupleGenConst(new HTuple(hv_Row.TupleLength()), 0, out hv_Zeros);
      hv_PointZOut = hv_PointZOut.TupleConcat(hv_Zeros);
      //
      hv_PolySequenceOut = hv_PolySequenceOut.TupleConcat(hv_Sequence);
      //
      ho_ContCircle.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_ContCircle.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void create_viewing_volume (HTuple hv_StartParam, HTuple hv_Dist, out HTuple hv_VolumeModel)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_L = null, hv_Width = null, hv_Height = null;
    HTuple hv_Sx = null, hv_Sy = null, hv_Focal = null, hv_SensorX = null;
    HTuple hv_SensorY = null, hv_SensorZ = null, hv_Length = null;
    HTuple hv_Factor = null, hv_FarX = null, hv_FarY = null;
    HTuple hv_FarZ = null, hv_PointX = null, hv_PointY = null;
    HTuple hv_PointZ = null, hv_PolySequence = null;
    // Initialize local and output iconic variables 
    hv_L = new HTuple(hv_StartParam.TupleLength());
    hv_Width = hv_StartParam.TupleSelect(hv_L-2);
    hv_Height = hv_StartParam.TupleSelect(hv_L-1);
    hv_Sx = hv_StartParam.TupleSelect(hv_L-6);
    hv_Sy = hv_StartParam.TupleSelect(hv_L-5);
    hv_Focal = hv_StartParam[0];
    //
    hv_SensorX = new HTuple();
    hv_SensorX = hv_SensorX.TupleConcat((0.5*hv_Width)*hv_Sx);
    hv_SensorX = hv_SensorX.TupleConcat((-0.5*hv_Width)*hv_Sx);
    hv_SensorX = hv_SensorX.TupleConcat((-0.5*hv_Width)*hv_Sx);
    hv_SensorX = hv_SensorX.TupleConcat((0.5*hv_Width)*hv_Sx);
    hv_SensorY = new HTuple();
    hv_SensorY = hv_SensorY.TupleConcat((-0.5*hv_Height)*hv_Sy);
    hv_SensorY = hv_SensorY.TupleConcat((-0.5*hv_Height)*hv_Sy);
    hv_SensorY = hv_SensorY.TupleConcat((0.5*hv_Height)*hv_Sy);
    hv_SensorY = hv_SensorY.TupleConcat((0.5*hv_Height)*hv_Sy);
    hv_SensorZ = new HTuple();
    hv_SensorZ = hv_SensorZ.TupleConcat(hv_Focal);
    hv_SensorZ = hv_SensorZ.TupleConcat(hv_Focal);
    hv_SensorZ = hv_SensorZ.TupleConcat(hv_Focal);
    hv_SensorZ = hv_SensorZ.TupleConcat(hv_Focal);
    //
    hv_Length = ((((hv_SensorX*hv_SensorX)+(hv_SensorY*hv_SensorY))+(hv_SensorZ*hv_SensorZ))).TupleSqrt()
        ;
    //
    //SensorZ + Fac*SensorZ/Length = 0.25
    hv_Factor = ((hv_Dist-hv_SensorZ)*hv_Length)/hv_SensorZ;
    //
    hv_FarX = hv_SensorX+((hv_Factor*hv_SensorX)/hv_Length);
    hv_FarY = hv_SensorY+((hv_Factor*hv_SensorY)/hv_Length);
    hv_FarZ = hv_SensorZ+((hv_Factor*hv_SensorZ)/hv_Length);
    //
    HOperatorSet.GenEmptyObjectModel3d(out hv_VolumeModel);
    hv_PointX = new HTuple();
    hv_PointX = hv_PointX.TupleConcat(hv_SensorX);
    hv_PointX = hv_PointX.TupleConcat(hv_FarX);
    hv_PointY = new HTuple();
    hv_PointY = hv_PointY.TupleConcat(hv_SensorY);
    hv_PointY = hv_PointY.TupleConcat(hv_FarY);
    hv_PointZ = new HTuple();
    hv_PointZ = hv_PointZ.TupleConcat(hv_SensorZ);
    hv_PointZ = hv_PointZ.TupleConcat(hv_FarZ);
    hv_PolySequence = new HTuple();
    hv_PolySequence[0] = 3;
    hv_PolySequence[1] = 1;
    hv_PolySequence[2] = 0;
    hv_PolySequence[3] = 4;
    hv_PolySequence[4] = 3;
    hv_PolySequence[5] = 1;
    hv_PolySequence[6] = 4;
    hv_PolySequence[7] = 5;
    hv_PolySequence[8] = 3;
    hv_PolySequence[9] = 1;
    hv_PolySequence[10] = 5;
    hv_PolySequence[11] = 6;
    hv_PolySequence[12] = 3;
    hv_PolySequence[13] = 2;
    hv_PolySequence[14] = 1;
    hv_PolySequence[15] = 6;
    hv_PolySequence[16] = 3;
    hv_PolySequence[17] = 3;
    hv_PolySequence[18] = 2;
    hv_PolySequence[19] = 6;
    hv_PolySequence[20] = 3;
    hv_PolySequence[21] = 3;
    hv_PolySequence[22] = 6;
    hv_PolySequence[23] = 7;
    hv_PolySequence[24] = 3;
    hv_PolySequence[25] = 0;
    hv_PolySequence[26] = 3;
    hv_PolySequence[27] = 7;
    hv_PolySequence[28] = 3;
    hv_PolySequence[29] = 0;
    hv_PolySequence[30] = 7;
    hv_PolySequence[31] = 4;
    //
    HOperatorSet.SetObjectModel3dAttribMod(hv_VolumeModel, ((new HTuple("point_coord_x")).TupleConcat(
        "point_coord_y")).TupleConcat("point_coord_z"), new HTuple(), ((hv_PointX.TupleConcat(
        hv_PointY))).TupleConcat(hv_PointZ));
    HOperatorSet.SetObjectModel3dAttribMod(hv_VolumeModel, "polygons", new HTuple(), 
        hv_PolySequence);

    return;
  }

  public void create_models (out HTuple hv_MarksModel, out HTuple hv_PlateModel, 
      out HTuple hv_CamModel, out HTuple hv_BaseModel)
  {


    // Local iconic variables 

    // Local control variables 

    HTuple hv_XNum = null, hv_YNum = null, hv_FinderX = null;
    HTuple hv_FinderY = null, hv_MarkDist = null, hv_DiameterRatio = null;
    HTuple hv_Pose = null;
    // Initialize local and output iconic variables 
    //Calibration target characteristics
    hv_XNum = 31;
    hv_YNum = 27;
    hv_FinderX = new HTuple();
    hv_FinderX[0] = 15;
    hv_FinderX[1] = 6;
    hv_FinderX[2] = 24;
    hv_FinderX[3] = 6;
    hv_FinderX[4] = 24;
    hv_FinderY = new HTuple();
    hv_FinderY[0] = 13;
    hv_FinderY[1] = 6;
    hv_FinderY[2] = 6;
    hv_FinderY[3] = 20;
    hv_FinderY[4] = 20;
    hv_MarkDist = 0.00258065;
    hv_DiameterRatio = 0.5;
    //
    //Create the model containing the calibration marks
    create_caltab_object_model(hv_XNum, hv_YNum, hv_MarkDist, hv_DiameterRatio, hv_FinderX, 
        hv_FinderY, out hv_MarksModel);
    //
    //Create the model containing the calibration object (without marks)
    HOperatorSet.CreatePose(0.0, 0.0, 0.0005, 0, 0, 0, "Rp+T", "gba", "point", out hv_Pose);
    HOperatorSet.GenBoxObjectModel3d(hv_Pose, (hv_XNum+2)*hv_MarkDist, ((hv_YNum+2)*((new HTuple(0.75)).TupleSqrt()
        ))*hv_MarkDist, 0.00099, out hv_PlateModel);
    //
    HOperatorSet.CreatePose(0.0, 0.0, 0.0005, 0, 0, 0, "Rp+T", "gba", "point", out hv_Pose);
    //Create models for camera and base plane
    HOperatorSet.GenBoxObjectModel3d(hv_Pose, 0.02, 0.02, 0.03, out hv_CamModel);
    HOperatorSet.GenBoxObjectModel3d(hv_Pose, 0.15, 0.15, 0.001, out hv_BaseModel);

    return;
  }

#if !NO_EXPORT_MAIN
  // Main procedure 
  private void action()
  {


    // Local iconic variables 

    HObject ho_Image, ho_MarkContours=null;

    // Local control variables 

    HTuple hv_AllCalibImageFiles = null, hv_ImageFiles = null;
    HTuple hv_Width = null, hv_Height = null, hv_WindowHandle = null;
    HTuple hv_Row = null, hv_Column = null, hv_WindowWidth = null;
    HTuple hv_WindowHeight = null, hv_WindowHandleConfig = null;
    HTuple hv_Message = null, hv_MarksModel = null, hv_PlateModel = null;
    HTuple hv_CamModel = null, hv_BaseModel = null, hv_CalibDataID = null;
    HTuple hv_CalPlateDescr = null, hv_StartParam = null, hv_Index = null;
    HTuple hv_StartPose = new HTuple(), hv_BasePoseWorld = new HTuple();
    HTuple hv_VolumeModel = new HTuple(), hv_CamWidth = new HTuple();
    HTuple hv_CamHeight = new HTuple(), hv_CamPar = new HTuple();
    HTuple hv_Scene = new HTuple(), hv_CameraIndex = new HTuple();
    HTuple hv_Origin = new HTuple(), hv_InstanceCamera = new HTuple();
    HTuple hv_InstanceBase = new HTuple(), hv_InstancePlate = new HTuple();
    HTuple hv_InstanceMarks = new HTuple(), hv_InstanceVolume = new HTuple();
    HTuple hv_Error = null, hv_CameraParametersCalibrated = null;
    HTuple hv_ParLabels = null, hv_Units = new HTuple(), hv_FormatStringLabels = null;
    HTuple hv_FormatStringParams = null, hv_CamParTable = null;
    HTuple hv_Text = null;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_MarkContours);
    try
    {
      //This example shows how to perform the basic calibration of a single
      //camera with multiple images of a calibration object.
      dev_update_off();
      //
      //Initialize visualization
      list_image_files("calib", "default", new HTuple(), out hv_AllCalibImageFiles);
      HOperatorSet.TupleRegexpSelect(hv_AllCalibImageFiles, "calib_single_camera", 
          out hv_ImageFiles);
      ho_Image.Dispose();
      HOperatorSet.ReadImage(out ho_Image, hv_ImageFiles.TupleSelect(0));
      HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
      }
      dev_open_window_fit_size(0, 0, hv_Width, hv_Height, 600, -1, out hv_WindowHandle);
      set_display_font(hv_WindowHandle, 14, "mono", "true", "false");
      HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_WindowWidth, 
          out hv_WindowHeight);
      HOperatorSet.SetWindowAttr("background_color","white");
      HOperatorSet.OpenWindow(0,hv_WindowWidth+12,1000-hv_WindowWidth,hv_WindowHeight,0,"","",out hv_WindowHandleConfig);
      HDevWindowStack.Push(hv_WindowHandleConfig);
      set_display_font(hv_WindowHandleConfig, 14, "mono", "true", "false");
      //
      //Create the 3d object models that visualize the current configuration
      //of camera and calibration plate. This may take a moment.
      hv_Message = "Creating 3D object models for visualization...";
      disp_message(hv_WindowHandle, hv_Message, "window", 12, 12, "gray", "false");
      create_models(out hv_MarksModel, out hv_PlateModel, out hv_CamModel, out hv_BaseModel);
      disp_message(hv_WindowHandle, "Ready.\nNow starting example...", "window", 
          32, 12, "gray", "false");
      HOperatorSet.WaitSeconds(.5);
      //
      //Part I
      //
      //Create and setup the calibration model
      //
      //First, create the calibration data structure
      HOperatorSet.CreateCalibData("calibration_object", 1, 1, out hv_CalibDataID);
      //Specify the used calibration plane using the name of the
      //description file
      hv_CalPlateDescr = "calplate_80mm.cpd";
      HOperatorSet.SetCalibDataCalibObject(hv_CalibDataID, 0, hv_CalPlateDescr);
      //Set the initial camera parameters
      //focus: 0.008 (use the nominal focal length of the used lens)
      //kappa: 0 (parameter for the division model for the lens distortion)
      //sx, sy: 3.7 μm (nominal pixel size of the used sensor)
      //cx, cy: 646,482 (use center of the image as initial values
      //                  for the principal point)
      //ImageWidth, ImageHeight (width and height of the used images)
      hv_StartParam = new HTuple();
      hv_StartParam[0] = 0.008;
      hv_StartParam[1] = 0;
      hv_StartParam[2] = 3.7e-006;
      hv_StartParam[3] = 3.7e-006;
      hv_StartParam[4] = 646;
      hv_StartParam[5] = 482;
      hv_StartParam[6] = 1292;
      hv_StartParam[7] = 964;
      HOperatorSet.SetCalibDataCamParam(hv_CalibDataID, 0, "area_scan_division", 
          hv_StartParam);
      //
      //Part II
      //
      //Extract calibration marks from the calibration images
      //
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ImageFiles.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        ho_Image.Dispose();
        HOperatorSet.ReadImage(out ho_Image, hv_ImageFiles.TupleSelect(hv_Index));
        //Extract the calibration marks.
        HOperatorSet.FindCalibObject(ho_Image, hv_CalibDataID, 0, 0, hv_Index, new HTuple(), 
            new HTuple());
        //
        //Visualize the extracted marks
        //
        HOperatorSet.GetCalibDataObservPose(hv_CalibDataID, 0, 0, hv_Index, out hv_StartPose);
        if ((int)(new HTuple(hv_Index.TupleEqual(0))) != 0)
        {
          //Just for visualization:
          //Create a 3D model of the viewing volume based on the
          //extracted pose in the first image.
          //(Assume that in image 0 the calibration plate is placed
          //on the base plate.)
          HOperatorSet.CreatePose(0.0, 0.0, (hv_StartPose.TupleSelect(2))+0.01, 0, 
              0, 0, "Rp+T", "gba", "point", out hv_BasePoseWorld);
          create_viewing_volume(hv_StartParam, (hv_StartPose.TupleSelect(2))+0.001, 
              out hv_VolumeModel);
          hv_CamWidth = 1000-hv_WindowWidth;
          hv_CamHeight = hv_WindowHeight.Clone();
          hv_CamPar = new HTuple();
          hv_CamPar[0] = 0.016;
          hv_CamPar[1] = 0;
          hv_CamPar[2] = 2.2e-6;
          hv_CamPar[3] = 2.2e-6;
          hv_CamPar = hv_CamPar.TupleConcat(hv_CamHeight/2);
          hv_CamPar = hv_CamPar.TupleConcat(hv_CamWidth/2);
          hv_CamPar = hv_CamPar.TupleConcat(hv_CamHeight);
          hv_CamPar = hv_CamPar.TupleConcat(hv_CamWidth);
          //setup the visualization scene
          HOperatorSet.CreateScene3d(out hv_Scene);
          HOperatorSet.AddScene3dCamera(hv_Scene, hv_CamPar, out hv_CameraIndex);
          HOperatorSet.CreatePose(0.0, 0.0, 0.0, 0, 0, 0, "Rp+T", "gba", "point", 
              out hv_Origin);
          //
          HOperatorSet.AddScene3dInstance(hv_Scene, hv_CamModel, hv_Origin, out hv_InstanceCamera);
          HOperatorSet.SetScene3dInstanceParam(hv_Scene, hv_InstanceCamera, "color", 
              "blue");
          HOperatorSet.SetScene3dInstanceParam(hv_Scene, hv_InstanceCamera, "disp_pose", 
              "true");
          //
          HOperatorSet.AddScene3dInstance(hv_Scene, hv_BaseModel, hv_BasePoseWorld, 
              out hv_InstanceBase);
          HOperatorSet.SetScene3dInstanceParam(hv_Scene, hv_InstanceBase, "color", 
              "gray");
          //
          HOperatorSet.AddScene3dInstance(hv_Scene, hv_PlateModel, hv_StartPose, 
              out hv_InstancePlate);
          HOperatorSet.SetScene3dInstanceParam(hv_Scene, hv_InstancePlate, "color", 
              "black");
          //
          HOperatorSet.AddScene3dInstance(hv_Scene, hv_MarksModel, hv_StartPose, 
              out hv_InstanceMarks);
          HOperatorSet.SetScene3dInstanceParam(hv_Scene, hv_InstanceMarks, "color", 
              "white");
          //
          HOperatorSet.AddScene3dInstance(hv_Scene, hv_VolumeModel, hv_Origin, out hv_InstanceVolume);
          HOperatorSet.SetScene3dInstanceParam(hv_Scene, hv_InstanceVolume, "color", 
              "yellow");
          HOperatorSet.SetScene3dInstanceParam(hv_Scene, hv_InstanceVolume, "alpha", 
              0.4);
          //
          HOperatorSet.SetScene3dToWorldPose(hv_Scene, ((((((new HTuple(-0.01)).TupleConcat(
              -0.07)).TupleConcat(4.0)).TupleConcat(306)).TupleConcat(2.2)).TupleConcat(
              330)).TupleConcat(0));
        }
        //Display the image and the centers of the calibration marks
        ho_MarkContours.Dispose();
        HOperatorSet.GetCalibDataObservContours(out ho_MarkContours, hv_CalibDataID, 
            "marks", 0, 0, hv_Index);
        HDevWindowStack.SetActive(hv_WindowHandle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetColored(HDevWindowStack.GetActive(), 12);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 1);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_MarkContours, HDevWindowStack.GetActive());
        }
        //Visualize the configuration of camera and calibration target
        HOperatorSet.SetScene3dInstancePose(hv_Scene, hv_InstancePlate, hv_StartPose);
        HOperatorSet.SetScene3dInstancePose(hv_Scene, hv_InstanceMarks, hv_StartPose);
        HOperatorSet.DisplayScene3d(hv_WindowHandleConfig, hv_Scene, hv_CameraIndex);
        disp_message(hv_WindowHandle, "Extracted marks in image "+hv_Index, "window", 
            12, 12, "black", "true");
        disp_message(hv_WindowHandleConfig, "Simulated view of pose "+hv_Index, "window", 
            12, 12, "black", "true");
        disp_continue_message(hv_WindowHandle, "black", "true");
        // stop(); only in hdevelop
      }
      //
      //Part III
      //
      //Finally calibrate the camera
      //
      HOperatorSet.CalibrateCameras(hv_CalibDataID, out hv_Error);
      HOperatorSet.GetCalibData(hv_CalibDataID, "camera", 0, "params", out hv_CameraParametersCalibrated);
      HOperatorSet.GetCalibData(hv_CalibDataID, "camera", 0, "params_labels", out hv_ParLabels);
      //
      //Display results
      HDevWindowStack.SetActive(hv_WindowHandle);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
      }
      if ((int)(new HTuple((new HTuple(hv_ParLabels.TupleLength())).TupleEqual(12))) != 0)
      {
        hv_Units = new HTuple();
        hv_Units[0] = "m";
        hv_Units[1] = "";
        hv_Units[2] = "";
        hv_Units[3] = "";
        hv_Units[4] = "";
        hv_Units[5] = "";
        hv_Units[6] = "m";
        hv_Units[7] = "m";
        hv_Units[8] = "px";
        hv_Units[9] = "px";
        hv_Units[10] = "px";
        hv_Units[11] = "px";
      }
      else
      {
        hv_Units = new HTuple();
        hv_Units[0] = "m";
        hv_Units[1] = "";
        hv_Units[2] = "m";
        hv_Units[3] = "m";
        hv_Units[4] = "px";
        hv_Units[5] = "px";
        hv_Units[6] = "px";
        hv_Units[7] = "px";
      }
      hv_FormatStringLabels = (((((hv_ParLabels.TupleStrlen())).TupleMax())).TupleString(
          "0"))+"s";
      hv_FormatStringParams = "";
      hv_CamParTable = ((((hv_ParLabels.TupleString(hv_FormatStringLabels))+" = ")+hv_CameraParametersCalibrated)+" ")+hv_Units;
      hv_Text = "The camera is now calibrated and ready for";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[1] = "high-accuracy metric measurements.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[2] = "The final camera parameters are:";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[3] = " ";
      hv_Message = new HTuple();
      hv_Message = hv_Message.TupleConcat(hv_Text);
      hv_Message = hv_Message.TupleConcat(hv_CamParTable);
      hv_Message = hv_Message.TupleConcat(" ");
      hv_Message = hv_Message.TupleConcat(("Back projection error = "+(hv_Error.TupleString(
          ".3f")))+" px");
      disp_message(hv_WindowHandle, hv_Message, "window", 12, 12, "black", "true");
      // stop(); only in hdevelop
      //
      //Part IV
      //
      //Cleanup
      HOperatorSet.ClearCalibData(hv_CalibDataID);
      HOperatorSet.ClearObjectModel3d(((((((hv_MarksModel.TupleConcat(hv_PlateModel))).TupleConcat(
          hv_CamModel))).TupleConcat(hv_BaseModel))).TupleConcat(hv_VolumeModel));
      HOperatorSet.ClearScene3d(hv_Scene);
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();
      ho_MarkContours.Dispose();

      throw HDevExpDefaultException;
    }
    ho_Image.Dispose();
    ho_MarkContours.Dispose();

  }

#endif


}
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
public class HDevelopExportApp
{
  static void Main(string[] args)
  {
    new HDevelopExport();
  }
}
#endif

